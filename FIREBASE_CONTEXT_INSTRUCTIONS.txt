================================================================================
                    GMEXPRESS - FIREBASE DATABASE CONTEXT
                    Documento de Contexto para IA
================================================================================

PROYECTO: GMEXPRESS-ASTRO
DESCRIPCIÓN: Plataforma web de servicio de alimentación/catering desarrollada con Astro.js
FIREBASE PROJECT ID: gmexpress-estesi
TECNOLOGÍAS: Astro.js (SSR con Vercel), Firebase (Firestore + Auth + Admin SDK), TypeScript, Tailwind CSS

================================================================================
                            CONFIGURACIÓN FIREBASE
================================================================================

CLIENTE (Frontend):
- Archivo de configuración: src/firebase/client.ts
- Servicios utilizados:
  - Firebase Authentication (getAuth)
  - Cloud Firestore (getFirestore)
- Instancias exportadas:
  - db: Instancia de Firestore
  - auth: Instancia de Authentication

ADMIN SDK (Backend/Server):
- Archivo de configuración: src/firebase/admin.ts
- Servicios utilizados:
  - Firebase Admin Auth (getAuth) - Para eliminar usuarios de Authentication
  - Firebase Admin Firestore (getFirestore) - Acceso privilegiado a la BD
- Instancias exportadas:
  - adminAuth: Instancia de Auth con privilegios de admin
  - adminDb: Instancia de Firestore con privilegios de admin
- Variables de entorno requeridas (.env):
  - FIREBASE_PROJECT_ID: ID del proyecto Firebase
  - FIREBASE_CLIENT_EMAIL: Email de la cuenta de servicio
  - FIREBASE_PRIVATE_KEY: Clave privada de la cuenta de servicio

NOTA: El Admin SDK ignora las reglas de seguridad de Firestore y tiene acceso completo.

================================================================================
                          CONFIGURACIÓN ASTRO (SSR)
================================================================================

MODO DE RENDERIZADO: Server-Side Rendering (SSR)
- Archivo: astro.config.mjs
- Output: 'server' (todas las páginas se renderizan en el servidor por defecto)
- Adapter: @astrojs/vercel (para despliegue en Vercel)

PÁGINAS CON DATOS DINÁMICOS DE FIREBASE:
Las siguientes páginas usan `export const prerender = false` para obtener
datos frescos de Firebase en cada solicitud (no se pre-renderizan):

- src/pages/index.astro - Productos destacados y servicios activos
- src/pages/productos.astro - Lista de productos activos
- src/pages/servicios.astro - Lista de servicios activos

MOTIVO: Sin SSR, los datos se obtenían solo durante el build y los nuevos
productos/servicios no aparecían hasta hacer un nuevo deploy.

================================================================================
                          API ENDPOINTS (Server-Side)
================================================================================

1. DELETE USER ENDPOINT
- Archivo: src/pages/api/admin/delete-user.ts
- Método: POST
- Propósito: Eliminar usuarios completamente de Firebase Auth Y Firestore
- Body esperado:
  {
    userId: string,      // ID del usuario a eliminar
    adminToken: string   // Token JWT del admin que hace la petición
  }
- Proceso:
  1. Valida que se envíen userId y adminToken
  2. Verifica el token con adminAuth.verifyIdToken()
  3. Confirma que el usuario que hace la petición es admin (role='admin')
  4. Previene auto-eliminación (admin no puede eliminarse a sí mismo)
  5. Elimina usuario de Firebase Authentication con adminAuth.deleteUser()
  6. Elimina documento de Firestore con adminDb.collection('users').doc().delete()
- Respuestas:
  - 200: { success: true, message: "Usuario eliminado completamente..." }
  - 400: Error de validación o intento de auto-eliminación
  - 401: Token inválido o no proporcionado
  - 403: Usuario no es administrador
  - 500: Error interno del servidor

NOTA IMPORTANTE: Sin este endpoint, eliminar usuarios solo desde el cliente
(deleteDoc) dejaba el usuario en Firebase Auth, permitiendo que siguiera
iniciando sesión y bloqueando la creación de nuevos usuarios con el mismo email.

================================================================================
                          COLECCIONES EN FIRESTORE
================================================================================

El proyecto utiliza 6 colecciones principales:

1. users
2. products
3. services
4. solicitudes
5. notifications
6. pedidos (NUEVO)

================================================================================
                        1. COLECCIÓN: users
================================================================================

PROPÓSITO: Almacenar información de usuarios registrados en la plataforma.

RUTA: /users/{userId}

ESTRUCTURA DEL DOCUMENTO:
{
  firstName: string,           // Nombre del usuario (ej: "Juan") - 2-50 caracteres
  lastNamePaterno: string,     // Apellido paterno (ej: "Pérez") - 2-50 caracteres
  lastNameMaterno: string,     // Apellido materno (ej: "González") - 2-50 caracteres
  rut: string,                 // RUT chileno formateado (ej: "12.345.678-9") - ÚNICO, 9-12 caracteres
  email: string,               // Correo electrónico del usuario - 5-100 caracteres, NO puede cambiar
  phone: string,               // Teléfono con formato chileno (ej: "+56 9 1234 5678") - 9-20 caracteres
  address: string,             // Dirección de calle y número - 5-200 caracteres
  region: string,              // Región de Chile - 3-100 caracteres
  comuna: string,              // Comuna de Chile - 3-100 caracteres
  apartment: string,           // Departamento/oficina (opcional) - máx 50 caracteres
  role: string,                // Rol del usuario: "user" | "admin"
  createdAt: Timestamp,        // Fecha de creación del usuario
  updatedAt: Timestamp         // Fecha de última actualización (solo en edición)
}

CÓMO SE CREA (REGISTRO PÚBLICO):
- Archivo: src/pages/registro.astro
- Proceso: 
  1. Validación de campos obligatorios con modal de errores UI
  2. Verificación de RUT duplicado en Firestore (query where rut == valor)
  3. Se crea usuario en Firebase Auth con createUserWithEmailAndPassword()
  4. Se actualiza el perfil con updateProfile() (displayName)
  5. Se guarda documento en Firestore con setDoc(doc(db, "users", user.uid), {...})
  6. El ID del documento es el UID del usuario de Firebase Auth
  7. Toast de éxito y redirección automática

CÓMO SE GESTIONA (PANEL ADMIN):
- Archivo: src/pages/admin/usuarios/index.astro
- Operaciones CRUD completas:
  - CREATE: createUserWithEmailAndPassword() + setDoc() con validación de RUT único
  - READ: onSnapshot con query a colección users
  - UPDATE: updateDoc() con validación de RUT único (excluyendo usuario actual)
  - DELETE: Llamada a API endpoint /api/admin/delete-user (elimina de Auth Y Firestore)

PROCESO DE ELIMINACIÓN DE USUARIOS:
1. Admin hace clic en "Eliminar" en el panel de usuarios
2. Se muestra modal de confirmación
3. Al confirmar, se obtiene el token JWT del admin actual
4. Se hace POST a /api/admin/delete-user con { userId, adminToken }
5. El servidor valida permisos y elimina de Firebase Auth + Firestore
6. Se muestra toast de éxito/error

NOTA: La eliminación DEBE hacerse vía API endpoint para eliminar de ambos
sistemas (Auth y Firestore). Usar solo deleteDoc() del cliente deja el
usuario en Auth, permitiendo login y bloqueando re-registro con mismo email.

VALIDACIONES IMPLEMENTADAS:
- Campos obligatorios: firstName, lastNamePaterno, lastNameMaterno, rut, email, phone, address, region, comuna
- RUT: Algoritmo de verificación chileno + verificación de unicidad en BD
- Teléfono: Regex para formato chileno (+56 9 XXXX XXXX)
- Email: Formato válido, no puede cambiar después de creación
- Contraseña: Mínimo 8 caracteres, mayúscula, minúscula, número, carácter especial (!@#$%^&*)
- Términos y condiciones: Checkbox obligatorio en registro público

REGLAS DE SEGURIDAD FIRESTORE:
- READ: Propietario del documento o admin
- CREATE: 
  - Usuario autenticado puede crear su propio documento (role='user' obligatorio)
  - Admin puede crear cualquier usuario con cualquier rol
- UPDATE:
  - Propietario puede actualizar su perfil (NO puede cambiar email ni rol)
  - Admin puede actualizar cualquier usuario (puede cambiar rol, NO puede cambiar email)
- DELETE: Solo admin

NOTAS IMPORTANTES:
- El campo "role" por defecto es "user"
- Los administradores tienen role: "admin"
- El RUT debe ser ÚNICO en toda la colección
- El email NO puede cambiar (está vinculado a Firebase Auth)
- Solo admin puede cambiar el rol de un usuario
- Se aplican validaciones de seguridad contra XSS en todos los campos de texto

================================================================================
                        2. COLECCIÓN: products
================================================================================

PROPÓSITO: Almacenar el catálogo de productos/platos disponibles para venta.

RUTA: /products/{productId}

ESTRUCTURA DEL DOCUMENTO:
{
  name: string,                // Nombre del producto (ej: "Pizza Suprema de la Casa")
  categoria: string,           // Categoría: "Pizza" | "Ensalada" | "Bebidas" | "Desayuno" | "Carnes"
  description: string,         // Descripción detallada del producto
  price: string,               // Precio formateado con $ (ej: "$16.990")
  stock: number,               // Cantidad en inventario (número entero)
  image: string,               // URL de la imagen del producto
  alt: string,                 // Texto alternativo para la imagen
  activo: boolean,             // Si el producto está disponible (true/false)
  destacado: boolean,          // Si el producto es destacado/featured (true/false)
  createdAt: Timestamp,        // Fecha de creación
  updatedAt: Timestamp         // Fecha de última actualización
}

CÓMO SE GESTIONA:
- Archivo: src/pages/admin/productos/index.astro
- Operaciones CRUD completas:
  - CREATE: addDoc(collection(db, "products"), productoData)
  - READ: onSnapshot con query ordenado por "name"
  - UPDATE: updateDoc(doc(db, "products", editingId), productoData)
  - DELETE: deleteDoc(doc(db, "products", deleteId))

CONSULTAS:
- Lista pública: query(productsCollection, where("activo", "==", true))
- Panel admin: query(productsCollection, orderBy("name"))

REGLAS DE SEGURIDAD:
- READ: Público (cualquiera puede leer)
- WRITE: Solo administradores

CATEGORÍAS DISPONIBLES:
1. Pizza
2. Ensalada
3. Bebidas
4. Desayuno
5. Carnes

================================================================================
                        3. COLECCIÓN: services
================================================================================

PROPÓSITO: Almacenar los servicios de catering/alimentación que ofrece la empresa.

RUTA: /services/{serviceId}

ESTRUCTURA DEL DOCUMENTO:
{
  name: string,                // Nombre del servicio (ej: "Catering para Eventos")
  description: string,         // Descripción del servicio
  image: string,               // URL de la imagen del servicio
  alt: string,                 // Texto alternativo para la imagen
  hasPrice: boolean,           // Si tiene precio definido (true) o "Consultar" (false)
  price: string,               // Precio formateado (ej: "$12.500") - solo si hasPrice=true
  priceLabel: string,          // Etiqueta de precio (ej: "/ por almuerzo") - opcional
  activo: boolean,             // Si el servicio está activo/disponible
  createdAt: Timestamp,        // Fecha de creación
  updatedAt: Timestamp         // Fecha de última actualización
}

CÓMO SE GESTIONA:
- Archivo: src/pages/admin/servicios/index.astro
- Operaciones CRUD completas:
  - CREATE: addDoc(collection(db, "services"), servicioData)
  - READ: onSnapshot con query ordenado por "name"
  - UPDATE: updateDoc(doc(db, "services", editingId), servicioData)
  - DELETE: deleteDoc(doc(db, "services", deleteId))

CONSULTAS:
- Servicios públicos: query(servicesCollection, where("activo", "==", true))
- Servicios sin precio (para cotización): 
  query(collection(db, "services"), where("hasPrice", "==", false), where("activo", "==", true))

REGLAS DE SEGURIDAD:
- READ: Público (cualquiera puede leer)
- WRITE: Solo administradores

================================================================================
                        4. COLECCIÓN: solicitudes
================================================================================

PROPÓSITO: Almacenar solicitudes de cotización enviadas por clientes interesados.

RUTA: /solicitudes/{solicitudId}

ESTRUCTURA DEL DOCUMENTO:
{
  id: string,                  // ID personalizado (ej: "SOL-123456")
  nombre: string,              // Nombre completo del contacto
  empresa: string,             // Nombre de la empresa
  email: string,               // Correo electrónico de contacto
  telefono: string,            // Teléfono de contacto
  ciudad: string,              // Ciudad del cliente
  servicio: string,            // Tipo de servicio solicitado
  numeroPersonas: number,      // Número de personas/empleados
  fechaEstimada: string,       // Fecha estimada de inicio (formato: "YYYY-MM-DD")
  descripcion: string,         // Descripción de necesidades específicas
  fecha: string,               // Fecha de creación (formato: "YYYY-MM-DD")
  estado: string,              // Estado: "Pendiente" | "En Proceso" | "Completada"
  prioridad: string,           // Prioridad: "Alta" | "Media" | "Baja" (opcional)
  createdAt: Timestamp         // Timestamp de Firebase (serverTimestamp())
}

CÓMO SE CREA:
- Archivo: src/components/servicios/SolicitudForm.astro
- Proceso:
  1. Usuario completa formulario de solicitud de cotización
  2. Se guarda con addDoc(collection(db, "solicitudes"), {...})
  3. Se genera ID personalizado: `SOL-${Date.now().toString().slice(-6)}`
  4. Estado inicial: "Pendiente"
  5. Se crea notificación automática para admin

CÓMO SE GESTIONA:
- Archivo: src/pages/admin/pedidos/index.astro (pestaña "Solicitudes de Cotización")
- Los administradores pueden:
  - Ver lista de solicitudes en tiempo real (onSnapshot)
  - Ver detalle de cada solicitud
  - Cambiar estado: updateDoc(doc(db, "solicitudes", docId), { estado: nuevoEstado })
  - Filtrar por estado, servicio, fecha

REGLAS DE SEGURIDAD:
- CREATE: Público (cualquiera puede crear)
- READ, UPDATE, DELETE: Solo administradores

================================================================================
                        5. COLECCIÓN: notifications
================================================================================

PROPÓSITO: Sistema de notificaciones para alertar a los administradores.

RUTA: /notifications/{notificationId}

ESTRUCTURA DEL DOCUMENTO:
{
  title: string,               // Título de la notificación
  message: string,             // Mensaje/descripción de la notificación
  type: string,                // Tipo: "info" | "warning" | "success" | "error"
  read: boolean,               // Si fue leída (true/false)
  createdAt: Timestamp         // Timestamp de creación (serverTimestamp())
}

CÓMO SE CREA:
Las notificaciones se crean automáticamente en ciertos eventos:

1. Nueva solicitud de cotización:
   - Archivo: src/components/servicios/SolicitudForm.astro
   - Trigger: Cuando un cliente envía una solicitud
   - Ejemplo:
     {
       title: "Nueva Solicitud de Cotización",
       message: "Nueva solicitud de Catering para Eventos por Juan Pérez (Empresa ABC)",
       type: "warning",
       read: false,
       createdAt: serverTimestamp()
     }

2. Cambio de estado de solicitud:
   - Archivo: src/pages/admin/pedidos/index.astro
   - Trigger: Cuando admin cambia estado de solicitud
   - Ejemplo:
     {
       title: "Estado Actualizado",
       message: "La solicitud #SOL-123456 cambió de Pendiente a En Proceso",
       type: "info",
       read: false,
       createdAt: serverTimestamp()
     }

REGLAS DE SEGURIDAD:
- CREATE: Público (para eventos del sistema)
- READ, UPDATE, DELETE: Solo administradores

================================================================================
                     REGLAS DE SEGURIDAD (firestore.rules)
================================================================================

El archivo firestore.rules define las siguientes funciones helper:

1. isAuthenticated(): Verifica si el usuario está autenticado
   return request.auth != null;

2. isAdmin(): Verifica si el usuario es administrador
   - Debe estar autenticado
   - Debe existir documento en /users/{uid}
   - El campo "role" debe ser "admin"

3. isOwner(userId): Verifica si el usuario es propietario del documento
   return isAuthenticated() && request.auth.uid == userId;

RESUMEN DE PERMISOS POR COLECCIÓN:
┌─────────────────┬────────────────┬────────────────────────────────┐
│ Colección       │ Lectura        │ Escritura                      │
├─────────────────┼────────────────┼────────────────────────────────┤
│ products        │ Público        │ Solo Admin                     │
│ services        │ Público        │ Solo Admin                     │
│ users           │ Owner o Admin  │ Owner o Admin                  │
│ solicitudes     │ Solo Admin     │ CREATE: Público, resto Admin   │
│ notifications   │ Solo Admin     │ CREATE: Público, resto Admin   │
└─────────────────┴────────────────┴────────────────────────────────┘

================================================================================
                          PATRONES DE USO COMÚN
================================================================================

1. LECTURA EN TIEMPO REAL (onSnapshot):
   Usado en paneles de administración para mantener datos actualizados.
   
   const q = query(collection(db, "products"), orderBy("name"));
   onSnapshot(q, (snapshot) => {
     const data = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
     // Actualizar UI
   });

2. LECTURA ÚNICA (getDocs):
   Usado en páginas públicas para cargar datos una vez.
   
   const q = query(collection(db, "products"), where("activo", "==", true));
   const snapshot = await getDocs(q);
   const products = snapshot.docs.map(doc => doc.data());

3. CREAR DOCUMENTO (addDoc):
   Para colecciones donde Firebase genera el ID automáticamente.
   
   await addDoc(collection(db, "solicitudes"), {
     ...formData,
     createdAt: serverTimestamp()
   });

4. CREAR/ACTUALIZAR CON ID ESPECÍFICO (setDoc):
   Usado cuando necesitas controlar el ID del documento.
   
   await setDoc(doc(db, "users", user.uid), {
     firstName: "Juan",
     role: "user",
     createdAt: new Date()
   });

5. ACTUALIZAR DOCUMENTO (updateDoc):
   Para actualizar campos específicos sin sobrescribir todo.
   
   await updateDoc(doc(db, "products", productId), {
     stock: 50,
     updatedAt: new Date()
   });

6. ELIMINAR DOCUMENTO (deleteDoc):
   
   await deleteDoc(doc(db, "products", productId));

================================================================================
                        FLUJOS DE DATOS IMPORTANTES
================================================================================

FLUJO 1: REGISTRO DE USUARIO
1. Usuario completa formulario en /registro
2. Se crea cuenta en Firebase Auth (createUserWithEmailAndPassword)
3. Se actualiza displayName en Auth (updateProfile)
4. Se crea documento en /users/{uid} con datos adicionales
5. Se redirige al usuario a la página principal

FLUJO 2: SOLICITUD DE COTIZACIÓN
1. Cliente completa formulario en /solicitud-cotizacion
2. Se crea documento en /solicitudes con estado "Pendiente"
3. Se crea notificación en /notifications
4. Admin ve nueva solicitud en panel (tiempo real)
5. Admin puede cambiar estado: Pendiente → En Proceso → Completada
6. Cada cambio de estado crea nueva notificación

FLUJO 3: GESTIÓN DE PRODUCTOS (ADMIN)
1. Admin accede a /admin/productos
2. Sistema carga productos con onSnapshot (tiempo real)
3. Admin puede crear/editar/eliminar productos
4. Cambios se reflejan inmediatamente en la UI
5. Productos activos aparecen en página pública /productos

FLUJO 4: GESTIÓN DE SERVICIOS (ADMIN)
1. Admin accede a /admin/servicios
2. Sistema carga servicios con onSnapshot (tiempo real)
3. Admin puede crear/editar/eliminar servicios
4. Servicios sin precio (hasPrice=false) aparecen en dropdown de cotizaciones
5. Servicios activos aparecen en página pública /servicios

================================================================================
                              VALIDACIONES
================================================================================

RUT CHILENO:
- Formato aceptado: "XX.XXX.XXX-X" o "X.XXX.XXX-X"
- Se valida con algoritmo de módulo 11
- Se formatea automáticamente al escribir

TELÉFONO CHILENO:
- Regex: /^(\+?56)?(\s?)(0?9)(\s?)[98765432]\d{7}$/
- Acepta: +56912345678, 912345678

CONTRASEÑA:
- Mínimo 8 caracteres
- Debe incluir mayúsculas, minúsculas y números
- Validación delegada a Firebase Auth

================================================================================
                  VALIDACIONES DE SEGURIDAD - CRUD ADMIN
================================================================================

ARCHIVOS AFECTADOS:
- src/pages/admin/productos/index.astro
- src/pages/admin/servicios/index.astro
- firestore.rules

--------------------------------------------------------------------------------
                    VALIDACIONES EN CLIENTE (JavaScript)
--------------------------------------------------------------------------------

CONFIGURACIÓN CENTRALIZADA (VALIDATION_CONFIG):
```javascript
const VALIDATION_CONFIG = {
  // PRODUCTOS
  NAME_MAX_LENGTH: 100,           // Máximo caracteres para nombre
  NAME_MIN_LENGTH: 3,             // Mínimo caracteres para nombre
  DESCRIPTION_MAX_LENGTH: 1000,   // Máximo caracteres para descripción
  DESCRIPTION_MIN_LENGTH: 10,     // Mínimo caracteres para descripción
  ALT_MAX_LENGTH: 200,            // Máximo para texto alternativo
  ALT_MIN_LENGTH: 5,              // Mínimo para texto alternativo
  
  // SERVICIOS
  SERVICE_NAME_MAX: 150,          // Máximo nombre servicio
  SERVICE_NAME_MIN: 5,            // Mínimo nombre servicio
  SERVICE_DESC_MAX: 2000,         // Máximo descripción servicio
  SERVICE_DESC_MIN: 20,           // Mínimo descripción servicio
  PRICE_LABEL_MAX: 50,            // Máximo etiqueta precio
  
  // NUMÉRICOS
  PRICE_MAX: 99999999,            // Precio máximo ($99.999.999)
  PRICE_MIN: 1,                   // Precio mínimo ($1)
  STOCK_MAX: 999999,              // Stock máximo
  STOCK_MIN: 0,                   // Stock mínimo (no negativos)
  
  // CATEGORÍAS PERMITIDAS (whitelist)
  ALLOWED_CATEGORIES: ["Pizza", "Ensalada", "Bebidas", "Desayuno", "Carnes"],
  
  // PATRONES DE DETECCIÓN DE ATAQUES
  PATTERNS: {
    URL: /^https?:\/\/[^\s<>"{}|\\^`[\]]+$/i,
    SAFE_TEXT: /^[a-zA-ZáéíóúÁÉÍÓÚñÑüÜ0-9\s.,\-()¡!¿?&%$#@*+=:;'"]+$/,
    SCRIPT_INJECTION: /<script[\s\S]*?>[\s\S]*?<\/script>|javascript:|on\w+\s*=/gi,
    HTML_INJECTION: /<[^>]*(iframe|object|embed|form|input|button|meta|link|style)[^>]*>/gi,
    NUMBERS_ONLY: /^\d+$/
  }
};
```

FUNCIONES DE VALIDACIÓN IMPLEMENTADAS:

1. sanitizeText(input: string): string
   - Elimina tags HTML
   - Escapa caracteres especiales (&, <, >, ", ')
   - Elimina caracteres de control
   - Previene ataques XSS

2. validateUrl(url: string): { isValid, error? }
   - Verifica prefijo http:// o https://
   - Bloquea javascript: y data:
   - Máximo 2048 caracteres

3. validatePrice(priceRaw: string): { isValid, value, error? }
   - DETECTA NÚMEROS NEGATIVOS antes de limpiar el string
   - Verifica rango $1 - $99.999.999
   - Solo acepta números enteros positivos
   - Error específico: "El precio no puede ser negativo"

4. validateStock(stockRaw: string): { isValid, value, error? }
   - Solo números enteros no negativos
   - Rango: 0 - 999.999
   - Previene números negativos

5. validateText(text, fieldName, min, max, allowSpecial): { isValid, value, error? }
   - Verifica longitud mínima y máxima
   - Detecta inyección de scripts
   - Detecta HTML peligroso

6. validateCategory(category: string): { isValid, error? }
   - Valida contra whitelist de categorías
   - Previene categorías manipuladas

7. validateProducto(data): ValidationResult
   - Ejecuta todas las validaciones
   - Retorna array de errores

8. validateServicio(data): ValidationResult
   - Ejecuta todas las validaciones para servicios
   - Valida precio condicionalmente (si hasPrice=true)

--------------------------------------------------------------------------------
                    UI DE ALERTAS DE VALIDACIÓN
--------------------------------------------------------------------------------

MODAL DE ERRORES (showValidationErrors):
- Modal centrado con Bootstrap 5
- Header rojo con icono de advertencia
- Lista de errores con iconos individuales
- Botón "Entendido" para cerrar
- Animación fade de entrada

TOASTS DE NOTIFICACIÓN (showToast):
- Tipos: success, info, warning, danger
- Iconos y colores específicos por tipo
- Animaciones slideInRight / slideOutRight
- Auto-cierre después de 4 segundos

ESTILOS CSS PERSONALIZADOS:
```css
@keyframes slideInRight { /* Entrada desde derecha */ }
@keyframes slideOutRight { /* Salida hacia derecha */ }
@keyframes shake { /* Vibración para campos con error */ }

.is-invalid {
  border-color: #dc3545 !important;
  animation: shake 0.5s ease-in-out;
}

.validation-error-list {
  max-height: 300px;
  overflow-y: auto;
}
```

--------------------------------------------------------------------------------
                    VALIDACIONES HTML5 EN FORMULARIOS
--------------------------------------------------------------------------------

PRODUCTOS - Campos del formulario:
┌──────────────┬────────────┬────────────┬─────────────────────────────────┐
│ Campo        │ Min Length │ Max Length │ Otras restricciones             │
├──────────────┼────────────┼────────────┼─────────────────────────────────┤
│ nombre       │ 3          │ 100        │ pattern de caracteres seguros   │
│ descripcion  │ 10         │ 1000       │ textarea                        │
│ precio       │ -          │ -          │ type=number, min=1, max=99999999│
│ stock        │ -          │ -          │ type=number, min=0, max=999999  │
│ imagen       │ -          │ 2048       │ type=url, pattern ^https?://    │
│ alt          │ 5          │ 200        │ texto alternativo accesibilidad │
└──────────────┴────────────┴────────────┴─────────────────────────────────┘

SERVICIOS - Campos del formulario:
┌──────────────┬────────────┬────────────┬─────────────────────────────────┐
│ Campo        │ Min Length │ Max Length │ Otras restricciones             │
├──────────────┼────────────┼────────────┼─────────────────────────────────┤
│ nombre       │ 5          │ 150        │ pattern de caracteres seguros   │
│ descripcion  │ 20         │ 2000       │ textarea                        │
│ precio       │ -          │ -          │ type=number, min=1, max=99999999│
│ priceLabel   │ -          │ 50         │ etiqueta opcional               │
│ imagen       │ -          │ 2048       │ type=url, pattern ^https?://    │
│ alt          │ 5          │ 200        │ texto alternativo accesibilidad │
└──────────────┴────────────┴────────────┴─────────────────────────────────┘

--------------------------------------------------------------------------------
                    VALIDACIONES EN SERVIDOR (Firestore Rules)
--------------------------------------------------------------------------------

FUNCIONES HELPER EN firestore.rules:

1. isValidStringLength(value, maxLength)
   - Valida que string no exceda límite

2. hasMinLength(value, minLength)
   - Valida longitud mínima

3. isInRange(value, min, max)
   - Valida rango numérico

4. isNonNegative(value)
   - Valida número >= 0

5. isPositiveInteger(value)
   - Valida entero positivo

6. isValidUrl(url)
   - Valida URL http/https

7. isSafeString(value)
   - Detecta patrones de inyección:
     * <script
     * javascript:
     * onerror
     * onclick
     * onload

REGLAS PARA PRODUCTS:
```
function isValidProduct(data) {
  return data.keys().hasAll([...campos requeridos...]) &&
         // Nombre: 3-100 caracteres, seguro
         hasMinLength(data.name, 3) &&
         isValidStringLength(data.name, 100) &&
         isSafeString(data.name) &&
         // Categoría: whitelist
         data.categoria in ['Pizza', 'Ensalada', 'Bebidas', 'Desayuno', 'Carnes'] &&
         // Descripción: 10-1000 caracteres, seguro
         hasMinLength(data.description, 10) &&
         isValidStringLength(data.description, 1000) &&
         isSafeString(data.description) &&
         // Stock: entero 0-999999
         isPositiveInteger(data.stock) &&
         isInRange(data.stock, 0, 999999) &&
         // URL imagen válida
         isValidUrl(data.image) &&
         // Alt: 5-200 caracteres, seguro
         hasMinLength(data.alt, 5) &&
         isValidStringLength(data.alt, 200) &&
         isSafeString(data.alt) &&
         // Booleanos
         data.activo is bool &&
         data.destacado is bool;
}
```

REGLAS PARA SERVICES:
```
function isValidService(data) {
  return data.keys().hasAll([...campos requeridos...]) &&
         // Nombre: 5-150 caracteres, seguro
         hasMinLength(data.name, 5) &&
         isValidStringLength(data.name, 150) &&
         isSafeString(data.name) &&
         // Descripción: 20-2000 caracteres, seguro
         hasMinLength(data.description, 20) &&
         isValidStringLength(data.description, 2000) &&
         isSafeString(data.description) &&
         // URL imagen válida
         isValidUrl(data.image) &&
         // Alt: 5-200 caracteres, seguro
         hasMinLength(data.alt, 5) &&
         isValidStringLength(data.alt, 200) &&
         isSafeString(data.alt) &&
         // Precio condicional
         (data.hasPrice == false || data.price is string) &&
         // PriceLabel opcional
         (!('priceLabel' in data.keys()) || isValidStringLength(data.priceLabel, 50)) &&
         data.activo is bool;
}
```

--------------------------------------------------------------------------------
                    PROTECCIONES IMPLEMENTADAS
--------------------------------------------------------------------------------

✅ XSS (Cross-Site Scripting)
   - Sanitización de HTML y scripts en cliente
   - Detección de patrones en Firestore Rules

✅ Inyección de datos maliciosos
   - Detección de <script>, javascript:, eventos on*
   - Bloqueo en cliente y servidor

✅ Números negativos
   - Precio: detecta signo "-" ANTES de procesar
   - Stock: validación min=0

✅ Categorías manipuladas
   - Whitelist en cliente (VALIDATION_CONFIG)
   - Whitelist en servidor (Firestore Rules)

✅ URLs maliciosas
   - Bloqueo de javascript: y data:
   - Solo http:// y https://

✅ Overflow de datos
   - Límites de longitud en todos los campos
   - Validación en cliente Y servidor

✅ Manipulación de IDs
   - IDs generados por Firestore (no manipulables)
   - Validación de userId en pedidos

================================================================================
                        CONSIDERACIONES TÉCNICAS
================================================================================

1. TIMESTAMPS:
   - Para campos de fecha en creación: serverTimestamp()
   - Para actualizaciones: new Date()

2. PRECIOS:
   - Se almacenan como strings formateados: "$16.990"
   - Para cálculos, se limpia el formato: price.replace(/[^0-9]/g, '')

3. IDs DE DOCUMENTOS:
   - users: Usa el UID de Firebase Auth
   - Otras colecciones: ID autogenerado por Firestore

4. ORDENAMIENTO:
   - Productos: orderBy("name")
   - Servicios: orderBy("name")
   - Solicitudes: orderBy("createdAt", "desc") - cliente

================================================================================
                        6. COLECCIÓN: pedidos (NUEVO)
================================================================================

PROPÓSITO: Almacenar pedidos/órdenes de compra realizados por clientes desde el carrito.

RUTA: /pedidos/{pedidoId}

ESTRUCTURA DEL DOCUMENTO:
{
  id: string,                  // ID personalizado (ej: "PED-123456")
  userId: string,              // UID del usuario que realizó el pedido
  userEmail: string,           // Email del usuario
  userName: string,            // Nombre completo del usuario
  productos: [                 // Array de productos en el pedido
    {
      id: string,              // ID del producto
      name: string,            // Nombre del producto
      price: string,           // Precio formateado (ej: "$16.990")
      quantity: number,        // Cantidad solicitada
      subtotal: number         // price * quantity (calculado)
    }
  ],
  servicios: [                 // Array de servicios en el pedido
    {
      id: string,              // ID del servicio
      name: string,            // Nombre del servicio
      price: string            // Precio formateado o "Cotizar"
    }
  ],
  total: number,               // Total del pedido en número
  estado: string,              // Estado: "Pendiente" | "En Proceso" | "Enviado" | "Recibido"
  notas: string,               // Notas adicionales del cliente (opcional)
  createdAt: Timestamp,        // Fecha de creación (serverTimestamp())
  
  // CAMPOS DE AUDITORÍA (agregados automáticamente)
  updatedAt: Timestamp,        // Última actualización (serverTimestamp())
  updatedBy: string            // UID del admin que actualizó el estado
}

CÓMO SE CREA:
- Archivo: src/pages/productos.astro (modal de checkout)
- Proceso:
  1. Usuario agrega productos/servicios al carrito (store nanostores)
  2. Usuario abre modal de checkout
  3. Se verifica autenticación (requiere login)
  4. Se ejecuta TRANSACCIÓN de Firestore:
     a. Se leen los precios ACTUALES de cada producto desde DB
     b. Se comparan con los precios del carrito (seguridad anti-manipulación)
     c. Si hay diferencias, se alerta al usuario
     d. Se calcula el total con precios verificados del servidor
     e. Se crea el pedido con addDoc()
  5. Se crea notificación automática para admin
  6. Se limpia el carrito local

SEGURIDAD - VERIFICACIÓN DE PRECIOS:
Para prevenir manipulación de precios desde el cliente, se implementa una transacción:

```javascript
await runTransaction(db, async (transaction) => {
  // Leer precios actuales de cada producto
  for (const item of items) {
    const productRef = doc(db, "products", item.id);
    const productDoc = await transaction.get(productRef);
    const currentPrice = productDoc.data().price;
    
    // Comparar con precio del carrito
    if (currentPrice !== item.price) {
      throw new Error("Precio ha cambiado");
    }
  }
  
  // Crear pedido con precios verificados
  const pedidoRef = doc(collection(db, "pedidos"));
  transaction.set(pedidoRef, pedidoData);
});
```

CÓMO SE GESTIONA:
- Archivo: src/pages/admin/pedidos/index.astro (pestaña "Pedidos")
- Los administradores pueden:
  - Ver lista de pedidos en tiempo real (onSnapshot)
  - Ver detalle completo de cada pedido (productos, servicios, totales)
  - Cambiar estado del pedido (genera log de auditoría)
  - Filtrar por estado y fecha

CAMPOS DE AUDITORÍA:
Cada cambio de estado registra:
- updatedAt: Timestamp del cambio
- updatedBy: UID del administrador que realizó el cambio

Ejemplo de actualización:
```javascript
await updateDoc(doc(db, "pedidos", pedidoId), {
  estado: nuevoEstado,
  updatedAt: serverTimestamp(),
  updatedBy: currentUser.uid
});
```

REGLAS DE SEGURIDAD:
- CREATE: Solo usuarios autenticados
- READ: Solo Admin o el propietario del pedido
- UPDATE: Solo Admin
- DELETE: Solo Admin

================================================================================
                        7. CARRITO DE COMPRAS (STORE)
================================================================================

PROPÓSITO: Estado local para gestionar el carrito de compras del usuario.

ARCHIVO: src/stores/cart.ts
TECNOLOGÍA: Nanostores (estado reactivo para Astro)

ESTRUCTURA DEL STORE:
```typescript
import { atom, computed } from 'nanostores';

// Items en el carrito (productos + servicios)
export const cartItems = atom<CartItem[]>([]);

// Contador computado de items
export const cartCount = computed(cartItems, items => items.length);

// Acciones disponibles
export function addToCart(item: CartItem): void;
export function removeFromCart(id: string): void;
export function updateQuantity(id: string, quantity: number): void;
export function clearCart(): void;

// Persistencia en localStorage
// El carrito se guarda automáticamente y se restaura al cargar la página
```

INTERFAZ CartItem:
```typescript
interface CartItem {
  id: string;
  type: 'product' | 'service';
  name: string;
  price: string;          // "$16.990" o "Cotizar"
  quantity: number;       // Solo para productos
  image?: string;
}
```

USO EN COMPONENTES:
```javascript
import { cartItems, addToCart, removeFromCart, cartCount } from '../stores/cart';

// Agregar producto
addToCart({
  id: product.id,
  type: 'product',
  name: product.name,
  price: product.price,
  quantity: 1,
  image: product.image
});

// Suscribirse a cambios
cartItems.subscribe(items => {
  // Actualizar UI
});

// Leer valor actual
const items = cartItems.get();
```

================================================================================
                     DASHBOARD ADMIN - DATOS EN TIEMPO REAL
================================================================================

ARCHIVO: src/pages/admin/index.astro

ESTADÍSTICAS DEL DASHBOARD:
El panel de administración muestra estadísticas en tiempo real usando onSnapshot:

1. USUARIOS REGISTRADOS:
   - Query: collection(db, "users")
   - Contador: snapshot.size
   - Actualización: Tiempo real con onSnapshot

2. PEDIDOS DEL MES:
   - Query: collection(db, "pedidos") con filtro de fecha >= primer día del mes
   - Contador: snapshot.size
   - Actualización: Tiempo real con onSnapshot

3. ACTIVIDAD RECIENTE:
   - Query: collection(db, "notifications") ordenado por createdAt desc, limit(10)
   - Muestra: Título, mensaje, tiempo relativo (formatTimeAgo)
   - Indicador visual de no leídas

4. PRODUCTOS MÁS VENDIDOS:
   - Fuente: Colección pedidos, campo productos[]
   - Cálculo: Agrupa por producto y suma cantidades
   - Muestra: Top 5 productos con unidades vendidas

CÓDIGO DE REFERENCIA:
```javascript
// Usuarios
onSnapshot(collection(db, "users"), (snapshot) => {
  document.getElementById("stat-users").textContent = snapshot.size.toString();
});

// Pedidos del mes
const startOfMonth = new Date();
startOfMonth.setDate(1);
startOfMonth.setHours(0, 0, 0, 0);

const pedidosQuery = query(
  collection(db, "pedidos"),
  where("createdAt", ">=", startOfMonth)
);

onSnapshot(pedidosQuery, (snapshot) => {
  document.getElementById("stat-pedidos-mes").textContent = snapshot.size.toString();
});

// Actividad reciente (notifications)
const notifQuery = query(
  collection(db, "notifications"),
  orderBy("createdAt", "desc"),
  limit(10)
);

onSnapshot(notifQuery, (snapshot) => {
  // Renderizar lista de actividad
});
```

================================================================================
                     HEADER ADMIN - PERFIL DE USUARIO
================================================================================

ARCHIVO: src/components/admin/AdminHeader.astro

DROPDOWN DE PERFIL:
Al hacer clic en el icono de usuario se muestra:
- Avatar con inicial del nombre
- Nombre completo
- Email
- Rol (badge Admin/Usuario)
- Teléfono
- Último inicio de sesión
- Botón de cerrar sesión

DATOS MOSTRADOS:
```javascript
// Desde documento de Firestore (/users/{uid})
const firstName = data.firstName || data.nombre;
const lastName = data.lastNamePaterno || data.apellidoPaterno;
const phone = data.phone || data.telefono;
const role = data.role;

// Desde Firebase Auth metadata
const lastLogin = user.metadata.lastSignInTime;
```

================================================================================
                  SISTEMA DE VALIDACIÓN Y ALERTAS UI
================================================================================

DESCRIPCIÓN:
Sistema unificado de validación de formularios con feedback visual mediante
toasts (notificaciones) y modales de errores de validación.

ARCHIVOS QUE IMPLEMENTAN EL SISTEMA:
- src/pages/registro.astro (registro público)
- src/pages/admin/usuarios/index.astro (CRUD admin)
- src/pages/admin/servicios/index.astro (referencia original)

--------------------------------------------------------------------------------
                           FUNCIONES DE UI
--------------------------------------------------------------------------------

1. showToast(message, type)
   - Muestra notificación temporal en esquina superior derecha
   - Tipos: "success" (verde), "info" (azul), "warning" (amarillo), "danger" (rojo)
   - Auto-cierre después de 5 segundos
   - Animación de entrada/salida con CSS

2. showValidationErrors(errors[])
   - Muestra modal con lista de errores de validación
   - Animación de shake para llamar atención
   - Botón para cerrar
   - Lista ordenada de errores

3. clearFieldErrors()
   - Limpia errores previos antes de nueva validación

--------------------------------------------------------------------------------
                     VALIDACIONES DE CONTRASEÑA
--------------------------------------------------------------------------------

Requisitos de contraseña (registro público y admin):
- Mínimo 8 caracteres
- Al menos una letra mayúscula (A-Z)
- Al menos una letra minúscula (a-z)
- Al menos un número (0-9)
- Al menos un carácter especial (!@#$%^&*)
- Confirmación de contraseña debe coincidir

Función: validatePassword(password, confirmPassword)
Retorna: { isValid: boolean, errors: string[] }

--------------------------------------------------------------------------------
                     VALIDACIÓN DE RUT DUPLICADO
--------------------------------------------------------------------------------

PROPÓSITO: Evitar que se registren usuarios con RUT ya existente en la BD.

IMPLEMENTACIÓN:
```javascript
async function checkRutExists(rut, excludeUserId?) {
  const rutQuery = query(usersCollection, where("rut", "==", rut));
  const querySnapshot = await getDocs(rutQuery);
  
  if (querySnapshot.empty) return false;
  
  // En edición, excluir el usuario actual
  if (excludeUserId) {
    return querySnapshot.docs.some(doc => doc.id !== excludeUserId);
  }
  
  return true;
}
```

USO:
- Registro público: Verifica antes de crear usuario en Auth
- Admin crear: Verifica antes de crear usuario
- Admin editar: Verifica excluyendo el ID del usuario que se edita

MENSAJE DE ERROR:
- Registro: "El RUT ingresado ya está registrado en el sistema. Si ya tienes una cuenta, inicia sesión."
- Admin: "El RUT ingresado ya está registrado en el sistema por otro usuario."

--------------------------------------------------------------------------------
                     VALIDACIÓN DE CAMPOS VACÍOS
--------------------------------------------------------------------------------

ARCHIVO: src/pages/registro.astro

La validación nativa HTML5 (atributo required) fue REMOVIDA para usar
validación personalizada con mensajes en modal UI.

Campos obligatorios validados:
- firstName (Nombre)
- lastNamePaterno (Apellido Paterno)
- lastNameMaterno (Apellido Materno)
- rut (RUT)
- email (Correo Electrónico)
- phone (Teléfono)
- address (Calle y Número)
- region (Región)
- comuna (Comuna)
- password (Contraseña)
- confirmPassword (Confirmar Contraseña)
- terms (Checkbox de Términos y Condiciones)

--------------------------------------------------------------------------------
                     ESTILOS CSS PARA ALERTAS
--------------------------------------------------------------------------------

Animaciones definidas en <style> de cada página:

@keyframes slideInRight - Entrada del toast desde derecha
@keyframes slideOutRight - Salida del toast hacia derecha
@keyframes shake - Vibración del modal de errores
@keyframes fadeIn - Aparición gradual del overlay
@keyframes slideUp - Entrada del modal desde abajo

Clases CSS:
- .toast-container - Contenedor fijo en esquina superior derecha
- .toast-success/info/warning/danger - Bordes de color por tipo
- .validation-modal-overlay - Fondo oscuro del modal
- .validation-modal - Caja blanca centrada con errores

================================================================================
                     VARIABLES DE ENTORNO Y DESPLIEGUE
================================================================================

ARCHIVO: .env (NO subir a Git - está en .gitignore)

Variables requeridas para Firebase Admin SDK:
- FIREBASE_PROJECT_ID=gmexpress-estesi
- FIREBASE_CLIENT_EMAIL=firebase-adminsdk-xxxxx@gmexpress-estesi.iam.gserviceaccount.com
- FIREBASE_PRIVATE_KEY="-----BEGIN PRIVATE KEY-----\n...\n-----END PRIVATE KEY-----\n"

OBTENER CREDENCIALES:
1. Firebase Console → Project Settings (⚙️) → Service Accounts
2. Click en "Generate new private key"
3. Copiar valores del JSON descargado al .env

DESPLIEGUE EN VERCEL:
1. Las variables de entorno se configuran en Vercel Dashboard:
   - Settings → Environment Variables
   - Agregar las 3 variables (FIREBASE_PROJECT_ID, FIREBASE_CLIENT_EMAIL, FIREBASE_PRIVATE_KEY)
   - Seleccionar: Production, Preview, Development
2. El código se sube a GitHub normalmente (el .env no se sube)
3. Vercel despliega automáticamente al hacer push

NOTA: La FIREBASE_PRIVATE_KEY debe incluir los \n literales en Vercel.

================================================================================
                     ESTRUCTURA DE ARCHIVOS FIREBASE
================================================================================

src/
├── firebase/
│   ├── client.ts          # Configuración Firebase Client SDK (frontend)
│   └── admin.ts           # Configuración Firebase Admin SDK (backend/server)
├── pages/
│   ├── api/
│   │   └── admin/
│   │       └── delete-user.ts  # Endpoint para eliminar usuarios completo
│   ├── index.astro        # SSR - Datos dinámicos de Firebase
│   ├── productos.astro    # SSR - Datos dinámicos de Firebase
│   └── servicios.astro    # SSR - Datos dinámicos de Firebase

================================================================================
                              FIN DEL DOCUMENTO
================================================================================