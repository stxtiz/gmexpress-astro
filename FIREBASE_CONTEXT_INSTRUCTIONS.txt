================================================================================
                    GMEXPRESS - FIREBASE DATABASE CONTEXT
                    Documento de Contexto para IA
================================================================================

PROYECTO: GMEXPRESS-ASTRO
DESCRIPCIÓN: Plataforma web de servicio de alimentación/catering desarrollada con Astro.js
FIREBASE PROJECT ID: gmexpress-estesi
TECNOLOGÍAS: Astro.js, Firebase (Firestore + Auth), TypeScript, Tailwind CSS

================================================================================
                            CONFIGURACIÓN FIREBASE
================================================================================

Archivo de configuración: src/firebase/client.ts

Servicios utilizados:
- Firebase Authentication (getAuth)
- Cloud Firestore (getFirestore)

Las instancias exportadas son:
- db: Instancia de Firestore
- auth: Instancia de Authentication

================================================================================
                          COLECCIONES EN FIRESTORE
================================================================================

El proyecto utiliza 6 colecciones principales:

1. users
2. products
3. services
4. solicitudes
5. notifications
6. pedidos (NUEVO)

================================================================================
                        1. COLECCIÓN: users
================================================================================

PROPÓSITO: Almacenar información de usuarios registrados en la plataforma.

RUTA: /users/{userId}

ESTRUCTURA DEL DOCUMENTO:
{
  firstName: string,           // Nombre del usuario (ej: "Juan")
  lastNamePaterno: string,     // Apellido paterno (ej: "Pérez")
  lastNameMaterno: string,     // Apellido materno (ej: "González")
  rut: string,                 // RUT chileno formateado (ej: "12.345.678-9")
  email: string,               // Correo electrónico del usuario
  phone: string,               // Teléfono con formato chileno (ej: "+56 9 1234 5678")
  address: string,             // Dirección de calle y número
  region: string,              // Región de Chile
  comuna: string,              // Comuna de Chile
  apartment: string,           // Departamento/oficina (opcional)
  role: string,                // Rol del usuario: "user" | "admin"
  createdAt: Timestamp         // Fecha de creación del usuario
}

CÓMO SE CREA:
- Archivo: src/pages/registro.astro
- Proceso: 
  1. Se crea usuario en Firebase Auth con createUserWithEmailAndPassword()
  2. Se actualiza el perfil con updateProfile() (displayName)
  3. Se guarda documento en Firestore con setDoc(doc(db, "users", user.uid), {...})
  4. El ID del documento es el UID del usuario de Firebase Auth

REGLAS DE SEGURIDAD:
- READ: Solo el propietario (owner) o admin pueden leer
- WRITE: Solo el propietario (owner) o admin pueden escribir

NOTAS IMPORTANTES:
- El campo "role" por defecto es "user"
- Los administradores tienen role: "admin"
- El RUT se valida con algoritmo de verificación chileno
- El teléfono se valida con regex para formato chileno

================================================================================
                        2. COLECCIÓN: products
================================================================================

PROPÓSITO: Almacenar el catálogo de productos/platos disponibles para venta.

RUTA: /products/{productId}

ESTRUCTURA DEL DOCUMENTO:
{
  name: string,                // Nombre del producto (ej: "Pizza Suprema de la Casa")
  categoria: string,           // Categoría: "Pizza" | "Ensalada" | "Bebidas" | "Desayuno" | "Carnes"
  description: string,         // Descripción detallada del producto
  price: string,               // Precio formateado con $ (ej: "$16.990")
  stock: number,               // Cantidad en inventario (número entero)
  image: string,               // URL de la imagen del producto
  alt: string,                 // Texto alternativo para la imagen
  activo: boolean,             // Si el producto está disponible (true/false)
  destacado: boolean,          // Si el producto es destacado/featured (true/false)
  createdAt: Timestamp,        // Fecha de creación
  updatedAt: Timestamp         // Fecha de última actualización
}

CÓMO SE GESTIONA:
- Archivo: src/pages/admin/productos/index.astro
- Operaciones CRUD completas:
  - CREATE: addDoc(collection(db, "products"), productoData)
  - READ: onSnapshot con query ordenado por "name"
  - UPDATE: updateDoc(doc(db, "products", editingId), productoData)
  - DELETE: deleteDoc(doc(db, "products", deleteId))

CONSULTAS:
- Lista pública: query(productsCollection, where("activo", "==", true))
- Panel admin: query(productsCollection, orderBy("name"))

REGLAS DE SEGURIDAD:
- READ: Público (cualquiera puede leer)
- WRITE: Solo administradores

CATEGORÍAS DISPONIBLES:
1. Pizza
2. Ensalada
3. Bebidas
4. Desayuno
5. Carnes

================================================================================
                        3. COLECCIÓN: services
================================================================================

PROPÓSITO: Almacenar los servicios de catering/alimentación que ofrece la empresa.

RUTA: /services/{serviceId}

ESTRUCTURA DEL DOCUMENTO:
{
  name: string,                // Nombre del servicio (ej: "Catering para Eventos")
  description: string,         // Descripción del servicio
  image: string,               // URL de la imagen del servicio
  alt: string,                 // Texto alternativo para la imagen
  hasPrice: boolean,           // Si tiene precio definido (true) o "Consultar" (false)
  price: string,               // Precio formateado (ej: "$12.500") - solo si hasPrice=true
  priceLabel: string,          // Etiqueta de precio (ej: "/ por almuerzo") - opcional
  activo: boolean,             // Si el servicio está activo/disponible
  createdAt: Timestamp,        // Fecha de creación
  updatedAt: Timestamp         // Fecha de última actualización
}

CÓMO SE GESTIONA:
- Archivo: src/pages/admin/servicios/index.astro
- Operaciones CRUD completas:
  - CREATE: addDoc(collection(db, "services"), servicioData)
  - READ: onSnapshot con query ordenado por "name"
  - UPDATE: updateDoc(doc(db, "services", editingId), servicioData)
  - DELETE: deleteDoc(doc(db, "services", deleteId))

CONSULTAS:
- Servicios públicos: query(servicesCollection, where("activo", "==", true))
- Servicios sin precio (para cotización): 
  query(collection(db, "services"), where("hasPrice", "==", false), where("activo", "==", true))

REGLAS DE SEGURIDAD:
- READ: Público (cualquiera puede leer)
- WRITE: Solo administradores

================================================================================
                        4. COLECCIÓN: solicitudes
================================================================================

PROPÓSITO: Almacenar solicitudes de cotización enviadas por clientes interesados.

RUTA: /solicitudes/{solicitudId}

ESTRUCTURA DEL DOCUMENTO:
{
  id: string,                  // ID personalizado (ej: "SOL-123456")
  nombre: string,              // Nombre completo del contacto
  empresa: string,             // Nombre de la empresa
  email: string,               // Correo electrónico de contacto
  telefono: string,            // Teléfono de contacto
  ciudad: string,              // Ciudad del cliente
  servicio: string,            // Tipo de servicio solicitado
  numeroPersonas: number,      // Número de personas/empleados
  fechaEstimada: string,       // Fecha estimada de inicio (formato: "YYYY-MM-DD")
  descripcion: string,         // Descripción de necesidades específicas
  fecha: string,               // Fecha de creación (formato: "YYYY-MM-DD")
  estado: string,              // Estado: "Pendiente" | "En Proceso" | "Completada"
  prioridad: string,           // Prioridad: "Alta" | "Media" | "Baja" (opcional)
  createdAt: Timestamp         // Timestamp de Firebase (serverTimestamp())
}

CÓMO SE CREA:
- Archivo: src/components/servicios/SolicitudForm.astro
- Proceso:
  1. Usuario completa formulario de solicitud de cotización
  2. Se guarda con addDoc(collection(db, "solicitudes"), {...})
  3. Se genera ID personalizado: `SOL-${Date.now().toString().slice(-6)}`
  4. Estado inicial: "Pendiente"
  5. Se crea notificación automática para admin

CÓMO SE GESTIONA:
- Archivo: src/pages/admin/pedidos/index.astro (pestaña "Solicitudes de Cotización")
- Los administradores pueden:
  - Ver lista de solicitudes en tiempo real (onSnapshot)
  - Ver detalle de cada solicitud
  - Cambiar estado: updateDoc(doc(db, "solicitudes", docId), { estado: nuevoEstado })
  - Filtrar por estado, servicio, fecha

REGLAS DE SEGURIDAD:
- CREATE: Público (cualquiera puede crear)
- READ, UPDATE, DELETE: Solo administradores

================================================================================
                        5. COLECCIÓN: notifications
================================================================================

PROPÓSITO: Sistema de notificaciones para alertar a los administradores.

RUTA: /notifications/{notificationId}

ESTRUCTURA DEL DOCUMENTO:
{
  title: string,               // Título de la notificación
  message: string,             // Mensaje/descripción de la notificación
  type: string,                // Tipo: "info" | "warning" | "success" | "error"
  read: boolean,               // Si fue leída (true/false)
  createdAt: Timestamp         // Timestamp de creación (serverTimestamp())
}

CÓMO SE CREA:
Las notificaciones se crean automáticamente en ciertos eventos:

1. Nueva solicitud de cotización:
   - Archivo: src/components/servicios/SolicitudForm.astro
   - Trigger: Cuando un cliente envía una solicitud
   - Ejemplo:
     {
       title: "Nueva Solicitud de Cotización",
       message: "Nueva solicitud de Catering para Eventos por Juan Pérez (Empresa ABC)",
       type: "warning",
       read: false,
       createdAt: serverTimestamp()
     }

2. Cambio de estado de solicitud:
   - Archivo: src/pages/admin/pedidos/index.astro
   - Trigger: Cuando admin cambia estado de solicitud
   - Ejemplo:
     {
       title: "Estado Actualizado",
       message: "La solicitud #SOL-123456 cambió de Pendiente a En Proceso",
       type: "info",
       read: false,
       createdAt: serverTimestamp()
     }

REGLAS DE SEGURIDAD:
- CREATE: Público (para eventos del sistema)
- READ, UPDATE, DELETE: Solo administradores

================================================================================
                     REGLAS DE SEGURIDAD (firestore.rules)
================================================================================

El archivo firestore.rules define las siguientes funciones helper:

1. isAuthenticated(): Verifica si el usuario está autenticado
   return request.auth != null;

2. isAdmin(): Verifica si el usuario es administrador
   - Debe estar autenticado
   - Debe existir documento en /users/{uid}
   - El campo "role" debe ser "admin"

3. isOwner(userId): Verifica si el usuario es propietario del documento
   return isAuthenticated() && request.auth.uid == userId;

RESUMEN DE PERMISOS POR COLECCIÓN:
┌─────────────────┬────────────────┬────────────────────────────────┐
│ Colección       │ Lectura        │ Escritura                      │
├─────────────────┼────────────────┼────────────────────────────────┤
│ products        │ Público        │ Solo Admin                     │
│ services        │ Público        │ Solo Admin                     │
│ users           │ Owner o Admin  │ Owner o Admin                  │
│ solicitudes     │ Solo Admin     │ CREATE: Público, resto Admin   │
│ notifications   │ Solo Admin     │ CREATE: Público, resto Admin   │
└─────────────────┴────────────────┴────────────────────────────────┘

================================================================================
                          PATRONES DE USO COMÚN
================================================================================

1. LECTURA EN TIEMPO REAL (onSnapshot):
   Usado en paneles de administración para mantener datos actualizados.
   
   const q = query(collection(db, "products"), orderBy("name"));
   onSnapshot(q, (snapshot) => {
     const data = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
     // Actualizar UI
   });

2. LECTURA ÚNICA (getDocs):
   Usado en páginas públicas para cargar datos una vez.
   
   const q = query(collection(db, "products"), where("activo", "==", true));
   const snapshot = await getDocs(q);
   const products = snapshot.docs.map(doc => doc.data());

3. CREAR DOCUMENTO (addDoc):
   Para colecciones donde Firebase genera el ID automáticamente.
   
   await addDoc(collection(db, "solicitudes"), {
     ...formData,
     createdAt: serverTimestamp()
   });

4. CREAR/ACTUALIZAR CON ID ESPECÍFICO (setDoc):
   Usado cuando necesitas controlar el ID del documento.
   
   await setDoc(doc(db, "users", user.uid), {
     firstName: "Juan",
     role: "user",
     createdAt: new Date()
   });

5. ACTUALIZAR DOCUMENTO (updateDoc):
   Para actualizar campos específicos sin sobrescribir todo.
   
   await updateDoc(doc(db, "products", productId), {
     stock: 50,
     updatedAt: new Date()
   });

6. ELIMINAR DOCUMENTO (deleteDoc):
   
   await deleteDoc(doc(db, "products", productId));

================================================================================
                        FLUJOS DE DATOS IMPORTANTES
================================================================================

FLUJO 1: REGISTRO DE USUARIO
1. Usuario completa formulario en /registro
2. Se crea cuenta en Firebase Auth (createUserWithEmailAndPassword)
3. Se actualiza displayName en Auth (updateProfile)
4. Se crea documento en /users/{uid} con datos adicionales
5. Se redirige al usuario a la página principal

FLUJO 2: SOLICITUD DE COTIZACIÓN
1. Cliente completa formulario en /solicitud-cotizacion
2. Se crea documento en /solicitudes con estado "Pendiente"
3. Se crea notificación en /notifications
4. Admin ve nueva solicitud en panel (tiempo real)
5. Admin puede cambiar estado: Pendiente → En Proceso → Completada
6. Cada cambio de estado crea nueva notificación

FLUJO 3: GESTIÓN DE PRODUCTOS (ADMIN)
1. Admin accede a /admin/productos
2. Sistema carga productos con onSnapshot (tiempo real)
3. Admin puede crear/editar/eliminar productos
4. Cambios se reflejan inmediatamente en la UI
5. Productos activos aparecen en página pública /productos

FLUJO 4: GESTIÓN DE SERVICIOS (ADMIN)
1. Admin accede a /admin/servicios
2. Sistema carga servicios con onSnapshot (tiempo real)
3. Admin puede crear/editar/eliminar servicios
4. Servicios sin precio (hasPrice=false) aparecen en dropdown de cotizaciones
5. Servicios activos aparecen en página pública /servicios

================================================================================
                              VALIDACIONES
================================================================================

RUT CHILENO:
- Formato aceptado: "XX.XXX.XXX-X" o "X.XXX.XXX-X"
- Se valida con algoritmo de módulo 11
- Se formatea automáticamente al escribir

TELÉFONO CHILENO:
- Regex: /^(\+?56)?(\s?)(0?9)(\s?)[98765432]\d{7}$/
- Acepta: +56912345678, 912345678

CONTRASEÑA:
- Mínimo 8 caracteres
- Debe incluir mayúsculas, minúsculas y números
- Validación delegada a Firebase Auth

================================================================================
                        CONSIDERACIONES TÉCNICAS
================================================================================

1. TIMESTAMPS:
   - Para campos de fecha en creación: serverTimestamp()
   - Para actualizaciones: new Date()

2. PRECIOS:
   - Se almacenan como strings formateados: "$16.990"
   - Para cálculos, se limpia el formato: price.replace(/[^0-9]/g, '')

3. IDs DE DOCUMENTOS:
   - users: Usa el UID de Firebase Auth
   - Otras colecciones: ID autogenerado por Firestore

4. ORDENAMIENTO:
   - Productos: orderBy("name")
   - Servicios: orderBy("name")
   - Solicitudes: orderBy("createdAt", "desc") - cliente

================================================================================
                        6. COLECCIÓN: pedidos (NUEVO)
================================================================================

PROPÓSITO: Almacenar pedidos/órdenes de compra realizados por clientes desde el carrito.

RUTA: /pedidos/{pedidoId}

ESTRUCTURA DEL DOCUMENTO:
{
  id: string,                  // ID personalizado (ej: "PED-123456")
  userId: string,              // UID del usuario que realizó el pedido
  userEmail: string,           // Email del usuario
  userName: string,            // Nombre completo del usuario
  productos: [                 // Array de productos en el pedido
    {
      id: string,              // ID del producto
      name: string,            // Nombre del producto
      price: string,           // Precio formateado (ej: "$16.990")
      quantity: number,        // Cantidad solicitada
      subtotal: number         // price * quantity (calculado)
    }
  ],
  servicios: [                 // Array de servicios en el pedido
    {
      id: string,              // ID del servicio
      name: string,            // Nombre del servicio
      price: string            // Precio formateado o "Cotizar"
    }
  ],
  total: number,               // Total del pedido en número
  estado: string,              // Estado: "Pendiente" | "En Proceso" | "Enviado" | "Recibido"
  notas: string,               // Notas adicionales del cliente (opcional)
  createdAt: Timestamp,        // Fecha de creación (serverTimestamp())
  
  // CAMPOS DE AUDITORÍA (agregados automáticamente)
  updatedAt: Timestamp,        // Última actualización (serverTimestamp())
  updatedBy: string            // UID del admin que actualizó el estado
}

CÓMO SE CREA:
- Archivo: src/pages/productos.astro (modal de checkout)
- Proceso:
  1. Usuario agrega productos/servicios al carrito (store nanostores)
  2. Usuario abre modal de checkout
  3. Se verifica autenticación (requiere login)
  4. Se ejecuta TRANSACCIÓN de Firestore:
     a. Se leen los precios ACTUALES de cada producto desde DB
     b. Se comparan con los precios del carrito (seguridad anti-manipulación)
     c. Si hay diferencias, se alerta al usuario
     d. Se calcula el total con precios verificados del servidor
     e. Se crea el pedido con addDoc()
  5. Se crea notificación automática para admin
  6. Se limpia el carrito local

SEGURIDAD - VERIFICACIÓN DE PRECIOS:
Para prevenir manipulación de precios desde el cliente, se implementa una transacción:

```javascript
await runTransaction(db, async (transaction) => {
  // Leer precios actuales de cada producto
  for (const item of items) {
    const productRef = doc(db, "products", item.id);
    const productDoc = await transaction.get(productRef);
    const currentPrice = productDoc.data().price;
    
    // Comparar con precio del carrito
    if (currentPrice !== item.price) {
      throw new Error("Precio ha cambiado");
    }
  }
  
  // Crear pedido con precios verificados
  const pedidoRef = doc(collection(db, "pedidos"));
  transaction.set(pedidoRef, pedidoData);
});
```

CÓMO SE GESTIONA:
- Archivo: src/pages/admin/pedidos/index.astro (pestaña "Pedidos")
- Los administradores pueden:
  - Ver lista de pedidos en tiempo real (onSnapshot)
  - Ver detalle completo de cada pedido (productos, servicios, totales)
  - Cambiar estado del pedido (genera log de auditoría)
  - Filtrar por estado y fecha

CAMPOS DE AUDITORÍA:
Cada cambio de estado registra:
- updatedAt: Timestamp del cambio
- updatedBy: UID del administrador que realizó el cambio

Ejemplo de actualización:
```javascript
await updateDoc(doc(db, "pedidos", pedidoId), {
  estado: nuevoEstado,
  updatedAt: serverTimestamp(),
  updatedBy: currentUser.uid
});
```

REGLAS DE SEGURIDAD:
- CREATE: Solo usuarios autenticados
- READ: Solo Admin o el propietario del pedido
- UPDATE: Solo Admin
- DELETE: Solo Admin

================================================================================
                        7. CARRITO DE COMPRAS (STORE)
================================================================================

PROPÓSITO: Estado local para gestionar el carrito de compras del usuario.

ARCHIVO: src/stores/cart.ts
TECNOLOGÍA: Nanostores (estado reactivo para Astro)

ESTRUCTURA DEL STORE:
```typescript
import { atom, computed } from 'nanostores';

// Items en el carrito (productos + servicios)
export const cartItems = atom<CartItem[]>([]);

// Contador computado de items
export const cartCount = computed(cartItems, items => items.length);

// Acciones disponibles
export function addToCart(item: CartItem): void;
export function removeFromCart(id: string): void;
export function updateQuantity(id: string, quantity: number): void;
export function clearCart(): void;

// Persistencia en localStorage
// El carrito se guarda automáticamente y se restaura al cargar la página
```

INTERFAZ CartItem:
```typescript
interface CartItem {
  id: string;
  type: 'product' | 'service';
  name: string;
  price: string;          // "$16.990" o "Cotizar"
  quantity: number;       // Solo para productos
  image?: string;
}
```

USO EN COMPONENTES:
```javascript
import { cartItems, addToCart, removeFromCart, cartCount } from '../stores/cart';

// Agregar producto
addToCart({
  id: product.id,
  type: 'product',
  name: product.name,
  price: product.price,
  quantity: 1,
  image: product.image
});

// Suscribirse a cambios
cartItems.subscribe(items => {
  // Actualizar UI
});

// Leer valor actual
const items = cartItems.get();
```

================================================================================
                     DASHBOARD ADMIN - DATOS EN TIEMPO REAL
================================================================================

ARCHIVO: src/pages/admin/index.astro

ESTADÍSTICAS DEL DASHBOARD:
El panel de administración muestra estadísticas en tiempo real usando onSnapshot:

1. USUARIOS REGISTRADOS:
   - Query: collection(db, "users")
   - Contador: snapshot.size
   - Actualización: Tiempo real con onSnapshot

2. PEDIDOS DEL MES:
   - Query: collection(db, "pedidos") con filtro de fecha >= primer día del mes
   - Contador: snapshot.size
   - Actualización: Tiempo real con onSnapshot

3. ACTIVIDAD RECIENTE:
   - Query: collection(db, "notifications") ordenado por createdAt desc, limit(10)
   - Muestra: Título, mensaje, tiempo relativo (formatTimeAgo)
   - Indicador visual de no leídas

4. PRODUCTOS MÁS VENDIDOS:
   - Fuente: Colección pedidos, campo productos[]
   - Cálculo: Agrupa por producto y suma cantidades
   - Muestra: Top 5 productos con unidades vendidas

CÓDIGO DE REFERENCIA:
```javascript
// Usuarios
onSnapshot(collection(db, "users"), (snapshot) => {
  document.getElementById("stat-users").textContent = snapshot.size.toString();
});

// Pedidos del mes
const startOfMonth = new Date();
startOfMonth.setDate(1);
startOfMonth.setHours(0, 0, 0, 0);

const pedidosQuery = query(
  collection(db, "pedidos"),
  where("createdAt", ">=", startOfMonth)
);

onSnapshot(pedidosQuery, (snapshot) => {
  document.getElementById("stat-pedidos-mes").textContent = snapshot.size.toString();
});

// Actividad reciente (notifications)
const notifQuery = query(
  collection(db, "notifications"),
  orderBy("createdAt", "desc"),
  limit(10)
);

onSnapshot(notifQuery, (snapshot) => {
  // Renderizar lista de actividad
});
```

================================================================================
                     HEADER ADMIN - PERFIL DE USUARIO
================================================================================

ARCHIVO: src/components/admin/AdminHeader.astro

DROPDOWN DE PERFIL:
Al hacer clic en el icono de usuario se muestra:
- Avatar con inicial del nombre
- Nombre completo
- Email
- Rol (badge Admin/Usuario)
- Teléfono
- Último inicio de sesión
- Botón de cerrar sesión

DATOS MOSTRADOS:
```javascript
// Desde documento de Firestore (/users/{uid})
const firstName = data.firstName || data.nombre;
const lastName = data.lastNamePaterno || data.apellidoPaterno;
const phone = data.phone || data.telefono;
const role = data.role;

// Desde Firebase Auth metadata
const lastLogin = user.metadata.lastSignInTime;
```

================================================================================
                              FIN DEL DOCUMENTO
================================================================================